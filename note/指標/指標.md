## 指標
### 指標陣列
`int *p = 存取一個記憶體位置`
`int l[3]={1, 2, 3} => l是一個記憶體位置 -> 指向該串列的第一個元素的位置(l[0])`
| l[0] | l[1] | l[2] |
| ---- | ---- | ---- |
| 1    | 2    | 3    |

`int *p[3]={&l[0], &l[1], &l[2]} => p是一個指標的陣列, 可以存取多個指標`
| p[0]         | p[1]         | p[2]         |
| ------------ | ------------ | ------------ |
| (int *)&l[0] | (int *)&l[1] | (int *)&l[2] |

`int *k=l => k是一個指標, 將l隱性轉型成一個指標`
| k[0]         |
| ------------ |
| (int *)l[0] |
> k 跟 p 的用法一樣, 但是p多存了兩個位置

### 陣列的指標
`int (*q)[3] = &l => q是一個陣列的指標, 並指向"整個陣列";`
| q   |
| --- |
| l   |

> q因為包含了整個陣列, 因此是可以透過q來換算整個陣列的大小(這是k做不到的事, 因為k只指向l[0])

### 函式中傳遞二維陣列
```cpp=
#include <iostream>
using namespace std;

void print(int **v, int height, int width){
    for (int i=0 ; i<height ; i++){
        for (int j=0 ; j<width ; j++){
            cout << v[i][j] << " ";
        }
        cout << "\n";
    }
}

int main(){
    int l[2][3] = {{1, 2, 3}, {4, 5, 6}}; // 陣列
    int *p[2] = {l[0], l1]}; // 指標陣列
//  int *p[2] = {&l[0][0], &l[1][0]};
    print(p, 2, 3);
    // Q: 為什麼是(int *[2])的p可以變成(int **)?
    // A: 因為可以隱性轉型(int *[2])->(int **)

}
```

### 不定數量的二維陣列
```cpp=
#include <iostream>
using namespace std;

void print(int *v, int height, int width){
    for (int i=0 ; i<height ; i++){
        for (int j=0 ; j<width ; j++){
            cout << *(v+i*width+j) << " ";
        }
        cout << "\n";
    }
}

int main(){
    int v[2][3] = {{1, 2, 3}, {4, 5, 6}}; // 陣列
    print((int *)v, 2, 3);
    return 0;
}
```